import{i as f,$ as wr}from"./index-a3888f1e.js";var ye=e=>e instanceof HTMLElement;const ie={BLUR:"blur",CHANGE:"change",INPUT:"input"},X={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},ar="select",xe="undefined",K={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"};function Cr({ref:e},t,n){ye(e)&&n&&(e.addEventListener(t?ie.CHANGE:ie.INPUT,n),e.addEventListener(ie.BLUR,n))}var G=e=>e==null;const lr=e=>typeof e=="object";var W=e=>!G(e)&&!Array.isArray(e)&&lr(e)&&!(e instanceof Date),Ae=e=>/^\w*$/.test(e),Z=e=>e.filter(Boolean),fr=e=>Z(e.replace(/["|']/g,"").replace(/\[/g,".").replace(/\]/g,"").split("."));function S(e,t,n){let c=-1;const a=Ae(t)?[t]:fr(t),u=a.length,o=u-1;for(;++c<u;){const g=a[c];let l=n;if(c!==o){const V=e[g];l=W(V)||Array.isArray(V)?V:isNaN(+a[c+1])?{}:[]}e[g]=l,e=e[g]}return e}var Ce=(e,t={})=>{for(const n in e)Ae(n)?t[n]=e[n]:S(t,n,e[n]);return t},M=e=>e===void 0,O=(e={},t,n)=>{const c=Z(t.split(/[,[\].]+?/)).reduce((a,u)=>G(a)?a:a[u],e);return M(c)||c===e?M(e[t])?n:e[t]:c},Dr=(e,t)=>{for(const n in e)if(O(t,n)){const c=e[n];if(c){if(c.ref.focus&&M(c.ref.focus()))break;if(c.options){c.options[0].ref.focus();break}}}},er=(e,t)=>{ye(e)&&e.removeEventListener&&(e.removeEventListener(ie.INPUT,t),e.removeEventListener(ie.CHANGE,t),e.removeEventListener(ie.BLUR,t))};const rr={isValid:!1,value:""};var dr=e=>Array.isArray(e)?e.reduce((t,n)=>n&&n.ref.checked?{isValid:!0,value:n.ref.value}:t,rr):rr,Lr=e=>[...e].filter(({selected:t})=>t).map(({value:t})=>t),Ee=e=>e.type==="radio",yr=e=>e.type==="file",ue=e=>e.type==="checkbox",gr=e=>e.type===`${ar}-multiple`;const tr={value:!1,isValid:!1},nr={value:!0,isValid:!0};var br=e=>{if(Array.isArray(e)){if(e.length>1){const a=e.filter(u=>u&&u.ref.checked).map(({ref:{value:u}})=>u);return{value:a,isValid:!!a.length}}const{checked:t,value:n,attributes:c}=e[0].ref;return t?c&&!M(c.value)?M(n)||n===""?nr:{value:n,isValid:!0}:nr:tr}return tr};function ce(e,t,n,c){const a=e.current[t];if(a){const{ref:{value:u,disabled:o},ref:g,valueAsNumber:l,valueAsDate:V,setValueAs:L}=a;return o&&c?void 0:yr(g)?g.files:Ee(g)?dr(a.options).value:gr(g)?Lr(g.options):ue(g)?br(a.options).value:l?+u:V?g.valueAsDate:L?L(u):u}if(n)return O(n.current,t)}function ke(e){return e?!(e instanceof HTMLElement)||e.nodeType===Node.DOCUMENT_NODE?!1:ke(e.parentNode):!0}var k=e=>W(e)&&!Object.keys(e).length,_e=e=>typeof e=="boolean";function Ir(e,t){const n=t.slice(0,-1).length;let c=0;for(;c<n;)e=M(e)?c++:e[t[c++]];return e}function B(e,t){const n=Ae(t)?[t]:fr(t),c=n.length==1?e:Ir(e,n),a=n[n.length-1];let u;c&&delete c[a];for(let o=0;o<n.slice(0,-1).length;o++){let g=-1,l;const V=n.slice(0,-(o+1)),L=V.length-1;for(o>0&&(u=e);++g<V.length;){const m=V[g];l=l?l[m]:e[m],L===g&&(W(l)&&k(l)||Array.isArray(l)&&!l.filter(C=>W(C)&&!k(C)||_e(C)).length)&&(u?delete u[m]:delete e[m]),u=l}}return e}const sr=(e,t)=>e&&e.ref===t;function Mr(e,t,n,c,a,u){const{ref:o,ref:{name:g}}=n,l=e.current[g];if(!a){const V=ce(e,g,c);!M(V)&&S(c.current,g,V)}if(!o.type||!l){delete e.current[g];return}Ee(o)||ue(o)?Array.isArray(l.options)&&l.options.length?(Z(l.options).forEach((V={},L)=>{(ke(V.ref)&&sr(V,V.ref)||u)&&(er(V.ref,t),B(l.options,`[${L}]`))}),l.options&&!Z(l.options).length&&delete e.current[g]):delete e.current[g]:(ke(o)&&sr(l,o)||u)&&(er(o,t),delete e.current[g])}var ee=e=>G(e)||!lr(e);function $e(e,t){if(ee(e)||ee(t))return t;for(const n in t){const c=e[n],a=t[n];try{e[n]=W(c)&&W(a)||Array.isArray(c)&&Array.isArray(a)?$e(c,a):a}catch{}}return e}function Be(e,t,n,c,a){let u=-1;for(;++u<e.length;){for(const o in e[u])Array.isArray(e[u][o])?(!n[u]&&(n[u]={}),n[u][o]=[],Be(e[u][o],O(t[u]||{},o,[]),n[u][o],n[u],o)):O(t[u]||{},o)===e[u][o]?S(n[u]||{},o):n[u]=Object.assign(Object.assign({},n[u]),{[o]:!0});c&&!n.length&&delete c[a]}return n}var Pr=(e,t,n)=>$e(Be(e,t,n),Be(t,e,n)),z=e=>typeof e=="string",Te=(e,t,n,c,a)=>{const u={};for(const o in e.current)(M(a)||(z(a)?o.startsWith(a):Array.isArray(a)&&a.find(g=>o.startsWith(g))))&&(u[o]=ce(e,o,void 0,c));return n?Ce(u):$e(t,Ce(u))};function se(e,t,n){if(ee(e)||ee(t)||e instanceof Date||t instanceof Date)return e===t;if(!f.isValidElement(e)){const c=Object.keys(e),a=Object.keys(t);if(c.length!==a.length)return!1;for(const u of c){const o=e[u];if(!(n&&u==="ref")){const g=t[u];if((W(o)||Array.isArray(o))&&(W(g)||Array.isArray(g))?!se(o,g,n):o!==g)return!1}}}return!0}var Tr=({errors:e,name:t,error:n,validFields:c,fieldsWithValidation:a})=>{const u=M(n),o=O(e,t);return u&&!!o||!u&&!se(o,n,!0)||u&&O(a,t)&&!O(c,t)},hr=e=>e instanceof RegExp,fe=e=>W(e)&&!hr(e)?e:{value:e,message:""},pr=e=>typeof e=="function",We=e=>z(e)||f.isValidElement(e);function cr(e,t,n="validate"){if(We(e)||_e(e)&&!e)return{type:n,message:We(e)?e:"",ref:t}}var Nr=(e,t,n,c,a)=>t?Object.assign(Object.assign({},n[e]),{types:Object.assign(Object.assign({},n[e]&&n[e].types?n[e].types:{}),{[c]:a||!0})}):{},we=async(e,t,{ref:n,ref:{value:c},options:a,required:u,maxLength:o,minLength:g,min:l,max:V,pattern:L,validate:m},C)=>{const P=n.name,E={},T=Ee(n),F=ue(n),ge=T||F,U=c==="",_=Nr.bind(null,P,t,E),x=(A,R,v,j=K.maxLength,N=K.minLength)=>{const Y=A?R:v;E[P]=Object.assign({type:A?j:N,message:Y,ref:n},_(A?j:N,Y))};if(u&&(!T&&!F&&(U||G(c))||_e(c)&&!c||F&&!br(a).isValid||T&&!dr(a).isValid)){const{value:A,message:R}=We(u)?{value:!!u,message:u}:fe(u);if(A&&(E[P]=Object.assign({type:K.required,message:R,ref:ge?((e.current[P].options||[])[0]||{}).ref:n},_(K.required,R)),!t))return E}if((!G(l)||!G(V))&&c!==""){let A,R;const v=fe(V),j=fe(l);if(isNaN(c)){const N=n.valueAsDate||new Date(c);z(v.value)&&(A=N>new Date(v.value)),z(j.value)&&(R=N<new Date(j.value))}else{const N=n.valueAsNumber||parseFloat(c);G(v.value)||(A=N>v.value),G(j.value)||(R=N<j.value)}if((A||R)&&(x(!!A,v.message,j.message,K.max,K.min),!t))return E}if(z(c)&&!U&&(o||g)){const A=fe(o),R=fe(g),v=!G(A.value)&&c.length>A.value,j=!G(R.value)&&c.length<R.value;if((v||j)&&(x(v,A.message,R.message),!t))return E}if(z(c)&&L&&!U){const{value:A,message:R}=fe(L);if(hr(A)&&!A.test(c)&&(E[P]=Object.assign({type:K.pattern,message:R,ref:n},_(K.pattern,R)),!t))return E}if(m){const A=ce(e,P,C),R=ge&&a?a[0].ref:n;if(pr(m)){const v=await m(A),j=cr(v,R);if(j&&(E[P]=Object.assign(Object.assign({},j),_(K.validate,j.message)),!t))return E}else if(W(m)){let v={};for(const[j,N]of Object.entries(m)){if(!k(v)&&!t)break;const Y=await N(A),be=cr(Y,R,j);be&&(v=Object.assign(Object.assign({},be),_(j,be.message)),t&&(E[P]=v))}if(!k(v)&&(E[P]=Object.assign({ref:R},v),!t))return E}}return E};const He=(e,t,n=[])=>{for(const c in t){const a=e+(W(t)?`.${c}`:`[${c}]`);ee(t[c])?n.push(a):He(a,t[c],n)}return n};var ir=(e,t,n,c,a)=>{let u;return n.add(t),k(e)||(u=O(e,t),(W(u)||Array.isArray(u))&&He(t,u).forEach(o=>n.add(o))),M(u)?a?c:O(c,t):u},Br=({isOnBlur:e,isOnChange:t,isOnTouch:n,isTouched:c,isReValidateOnBlur:a,isReValidateOnChange:u,isBlurEvent:o,isSubmitted:g,isOnAll:l})=>l?!1:!g&&n?!(c||o):(g?a:e)?!o:(g?u:t)?o:!0,Ne=e=>e.substring(0,e.indexOf("["));const Wr=(e,t)=>RegExp(`^${t}([|.)\\d+`.replace(/\[/g,"\\[").replace(/\]/g,"\\]")).test(e);var _r=(e,t)=>[...e].some(n=>Wr(t,n)),$r=e=>e.type===`${ar}-one`;function Hr(e,t){const n=new MutationObserver(()=>{for(const c of Object.values(e.current))if(c&&c.options)for(const a of c.options)a&&a.ref&&ke(a.ref)&&t(c);else c&&ke(c.ref)&&t(c)});return n.observe(window.document,{childList:!0,subtree:!0}),n}var de=typeof window!==xe&&typeof document!==xe;function Q(e){let t;if(ee(e)||de&&(e instanceof File||ye(e)))return e;if(e instanceof Date)return t=new Date(e.getTime()),t;if(e instanceof Set){t=new Set;for(const n of e)t.add(n);return t}if(e instanceof Map){t=new Map;for(const n of e.keys())t.set(n,Q(e.get(n)));return t}t=Array.isArray(e)?[]:{};for(const n in e)t[n]=Q(e[n]);return t}var ur=e=>({isOnSubmit:!e||e===X.onSubmit,isOnBlur:e===X.onBlur,isOnChange:e===X.onChange,isOnAll:e===X.all,isOnTouch:e===X.onTouched}),or=e=>Ee(e)||ue(e);const Gr=typeof window===xe,ne=de?"Proxy"in window:typeof Proxy!==xe;function Zr({mode:e=X.onSubmit,reValidateMode:t=X.onChange,resolver:n,context:c,defaultValues:a={},shouldFocusError:u=!0,shouldUnregister:o=!0,criteriaMode:g}={}){const l=f.useRef({}),V=f.useRef({}),L=f.useRef({}),m=f.useRef(new Set),C=f.useRef({}),P=f.useRef({}),E=f.useRef({}),T=f.useRef({}),F=f.useRef(a),ge=f.useRef(!1),U=f.useRef(!1),_=f.useRef(),x=f.useRef({}),A=f.useRef({}),R=f.useRef(c),v=f.useRef(n),j=f.useRef(new Set),N=f.useRef(ur(e)),{isOnSubmit:Y,isOnTouch:be}=N.current,$=g===X.all,[oe,Or]=f.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touched:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!Y,errors:{}}),I=f.useRef({isDirty:!ne,dirtyFields:!ne,touched:!ne||be,isValidating:!ne,isSubmitting:!ne,isValid:!ne}),d=f.useRef(oe),he=f.useRef(),{isOnBlur:qe,isOnChange:ze}=f.useRef(ur(t)).current;R.current=c,v.current=n,d.current=oe,x.current=o?{}:k(x.current)?Q(a):x.current;const w=f.useCallback((r={})=>{ge.current||(d.current=Object.assign(Object.assign({},d.current),r),Or(d.current))},[]),Ke=()=>I.current.isValidating&&w({isValidating:!0}),pe=f.useCallback((r,i,s=!1,h={},b)=>{let y=s||Tr({errors:d.current.errors,error:i,name:r,validFields:T.current,fieldsWithValidation:E.current});const p=O(d.current.errors,r);i?(B(T.current,r),y=y||!p||!se(p,i,!0),S(d.current.errors,r,i)):((O(E.current,r)||v.current)&&(S(T.current,r,!0),y=y||p),B(d.current.errors,r)),(y&&!G(s)||!k(h)||I.current.isValidating)&&w(Object.assign(Object.assign(Object.assign({},h),v.current?{isValid:!!b}:{}),{isValidating:!1}))},[]),Oe=f.useCallback((r,i)=>{const{ref:s,options:h}=l.current[r],b=de&&ye(s)&&G(i)?"":i;Ee(s)?(h||[]).forEach(({ref:y})=>y.checked=y.value===b):yr(s)&&!z(b)?s.files=b:gr(s)?[...s.options].forEach(y=>y.selected=b.includes(y.value)):ue(s)&&h?h.length>1?h.forEach(({ref:y})=>y.checked=Array.isArray(b)?!!b.find(p=>p===y.value):b===y.value):h[0].ref.checked=!!b:s.value=b},[]),De=f.useCallback((r,i)=>{if(I.current.isDirty){const s=ae();return r&&i&&S(s,r,i),!se(s,F.current)}return!1},[]),ve=f.useCallback((r,i=!0)=>{if(I.current.isDirty||I.current.dirtyFields){const s=!se(O(F.current,r),ce(l,r,x)),h=O(d.current.dirtyFields,r),b=d.current.isDirty;s?S(d.current.dirtyFields,r,!0):B(d.current.dirtyFields,r);const y={isDirty:De(),dirtyFields:d.current.dirtyFields},p=I.current.isDirty&&b!==y.isDirty||I.current.dirtyFields&&h!==O(d.current.dirtyFields,r);return p&&i&&w(y),p?y:{}}return{}},[]),Le=f.useCallback(async(r,i)=>{const s=(await we(l,$,l.current[r],x))[r];return pe(r,s,i),M(s)},[pe,$]),Ue=f.useCallback(async r=>{const{errors:i}=await v.current(ae(),R.current,$),s=d.current.isValid;if(Array.isArray(r)){const h=r.map(b=>{const y=O(i,b);return y?S(d.current.errors,b,y):B(d.current.errors,b),!y}).every(Boolean);return w({isValid:k(i),isValidating:!1}),h}else{const h=O(i,r);return pe(r,h,s!==k(i),{},k(i)),!h}},[pe,$]),Ve=f.useCallback(async r=>{const i=r||Object.keys(l.current);if(Ke(),v.current)return Ue(i);if(Array.isArray(i)){!r&&(d.current.errors={});const s=await Promise.all(i.map(async h=>await Le(h,null)));return w({isValidating:!1}),s.every(Boolean)}return await Le(i)},[Ue,Le]),Ye=f.useCallback((r,i,{shouldDirty:s,shouldValidate:h})=>{const b={};S(b,r,i);for(const y of He(r,i))l.current[y]&&(Oe(y,O(b,y)),s&&ve(y),h&&Ve(y))},[Ve,Oe,ve]),Je=f.useCallback((r,i,s)=>{if(!o&&!ee(i)&&S(x.current,r,Object.assign({},i)),l.current[r])Oe(r,i),s.shouldDirty&&ve(r),s.shouldValidate&&Ve(r);else if(!ee(i)&&(Ye(r,i,s),j.current.has(r))){const h=Ne(r)||r;S(V.current,r,i),A.current[h]({[h]:O(V.current,h)}),(I.current.isDirty||I.current.dirtyFields)&&s.shouldDirty&&(S(d.current.dirtyFields,r,Pr(i,O(F.current,r,[]),O(d.current.dirtyFields,r,[]))),w({isDirty:!se(Object.assign(Object.assign({},ae()),{[r]:i}),F.current)}))}!o&&S(x.current,r,i)},[ve,Oe,Ye]),Qe=r=>U.current||m.current.has(r)||m.current.has((r.match(/\w+/)||[])[0]),Re=r=>{let i=!0;if(!k(C.current))for(const s in C.current)(!r||!C.current[s].size||C.current[s].has(r)||C.current[s].has(Ne(r)))&&(P.current[s](),i=!1);return i};function vr(r,i,s){Je(r,i,s||{}),Qe(r)&&w(),Re(r)}_.current=_.current?_.current:async({type:r,target:i})=>{let s=i.name;const h=l.current[s];let b,y;if(h){const p=r===ie.BLUR,H=Br(Object.assign({isBlurEvent:p,isReValidateOnChange:ze,isReValidateOnBlur:qe,isTouched:!!O(d.current.touched,s),isSubmitted:d.current.isSubmitted},N.current));let q=ve(s,!1),le=!k(q)||!p&&Qe(s);if(p&&!O(d.current.touched,s)&&I.current.touched&&(S(d.current.touched,s,!0),q=Object.assign(Object.assign({},q),{touched:d.current.touched})),!o&&ue(i)&&S(x.current,s,ce(l,s)),H)return!p&&Re(s),(!k(q)||le&&k(q))&&w(q);if(Ke(),v.current){const{errors:D}=await v.current(ae(),R.current,$),me=d.current.isValid;if(b=O(D,s),ue(i)&&!b&&v.current){const J=Ne(s),re=O(D,J,{});re.type&&re.message&&(b=re),J&&(re||O(d.current.errors,J))&&(s=J)}y=k(D),me!==y&&(le=!0)}else b=(await we(l,$,h,x))[s];!p&&Re(s),pe(s,b,le,q,y)}};function Xe(r){if(!o){let i=Q(r);for(const s of j.current)Ae(s)&&!i[s]&&(i=Object.assign(Object.assign({},i),{[s]:[]}));return i}return r}function ae(r){if(z(r))return ce(l,r,x);if(Array.isArray(r)){const i={};for(const s of r)S(i,s,ce(l,s,x));return i}return Xe(Te(l,Q(x.current),o))}const je=f.useCallback(async(r={})=>{const{errors:i}=await v.current(Object.assign(Object.assign({},ae()),r),R.current,$),s=k(i);d.current.isValid!==s&&w({isValid:s})},[$]),Se=f.useCallback((r,i)=>Mr(l,_.current,r,x,o,i),[o]),Ie=f.useCallback(r=>{if(U.current)w();else{for(const i of m.current)if(i.startsWith(r)){w();break}Re(r)}},[]),Fe=f.useCallback((r,i)=>{r&&(Se(r,i),o&&!Z(r.options||[]).length&&(B(T.current,r.ref.name),B(E.current,r.ref.name),B(d.current.errors,r.ref.name),S(d.current.dirtyFields,r.ref.name,!0),w({isDirty:De()}),I.current.isValid&&v.current&&je(),Ie(r.ref.name)))},[je,Se]);function Vr(r){r&&(Array.isArray(r)?r:[r]).forEach(i=>l.current[i]&&Ae(i)?delete d.current.errors[i]:B(d.current.errors,i)),w({errors:r?d.current.errors:{}})}function Rr(r,i){const s=(l.current[r]||{}).ref;S(d.current.errors,r,Object.assign(Object.assign({},i),{ref:s})),w({isValid:!1}),i.shouldFocus&&s&&s.focus&&s.focus()}const Me=f.useCallback((r,i,s)=>{const h=s?C.current[s]:m.current;let b=Te(l,Q(x.current),o,!1,r);if(z(r)){if(j.current.has(r)){const p=O(L.current,r,[]);b=!p.length||p.length!==Z(O(b,r,[])).length?L.current:b}return ir(b,r,h,M(O(F.current,r))?i:O(F.current,r),!0)}const y=M(i)?F.current:i;return Array.isArray(r)?r.reduce((p,H)=>Object.assign(Object.assign({},p),{[H]:ir(b,H,h,y)}),{}):(U.current=M(s),Ce(!k(b)&&b||y))},[]);function mr(r,i){return Me(r,i)}function xr(r){for(const i of Array.isArray(r)?r:[r])Fe(l.current[i],!0)}function Pe(r,i={}){const{name:s,type:h,value:b}=r,y=Object.assign({ref:r},i),p=l.current,H=or(r),q=_r(j.current,s),le=te=>de&&(!ye(r)||te===r);let D=p[s],me=!0,J;if(D&&(H?Array.isArray(D.options)&&Z(D.options).find(te=>b===te.ref.value&&le(te.ref)):le(D.ref))){p[s]=Object.assign(Object.assign({},D),i);return}h?D=H?Object.assign({options:[...Z(D&&D.options||[]),{ref:r}],ref:{type:h,name:s}},i):Object.assign({},y):D=y,p[s]=D;const re=M(O(x.current,s));(!k(F.current)||!re)&&(J=O(re?F.current:x.current,s),me=M(J),!me&&!q&&Oe(s,J)),k(i)||(S(E.current,s,!0),!Y&&I.current.isValid&&we(l,$,D,x).then(te=>{const Fr=d.current.isValid;k(te)?S(T.current,s,!0):B(T.current,s),Fr!==k(te)&&w()})),q&&me||!q&&B(d.current.dirtyFields,s),h&&Cr(H&&D.options?D.options[D.options.length-1]:D,H||$r(r),_.current)}function Ar(r,i){if(!Gr)if(z(r))Pe({name:r},i);else if(W(r)&&"name"in r)Pe(r,i);else return s=>s&&Pe(s,r)}const kr=f.useCallback((r,i)=>async s=>{s&&s.preventDefault&&(s.preventDefault(),s.persist());let h={},b=Xe(Te(l,Q(x.current),o,!0));I.current.isSubmitting&&w({isSubmitting:!0});try{if(v.current){const{errors:y,values:p}=await v.current(b,R.current,$);d.current.errors=h=y,b=p}else for(const y of Object.values(l.current))if(y){const{name:p}=y.ref,H=await we(l,$,y,x);H[p]?(S(h,p,H[p]),B(T.current,p)):O(E.current,p)&&(B(d.current.errors,p),S(T.current,p,!0))}k(h)&&Object.keys(d.current.errors).every(y=>y in l.current)?(w({errors:{},isSubmitting:!0}),await r(b,s)):(d.current.errors=Object.assign(Object.assign({},d.current.errors),h),i&&await i(d.current.errors,s),u&&Dr(l.current,d.current.errors))}finally{d.current.isSubmitting=!1,w({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:k(d.current.errors),submitCount:d.current.submitCount+1})}},[u,$]),Er=({errors:r,isDirty:i,isSubmitted:s,touched:h,isValid:b,submitCount:y,dirtyFields:p})=>{b||(T.current={},E.current={}),V.current={},m.current=new Set,U.current=!1,w({submitCount:y?d.current.submitCount:0,isDirty:i?d.current.isDirty:!1,isSubmitted:s?d.current.isSubmitted:!1,isValid:b?d.current.isValid:!1,dirtyFields:p?d.current.dirtyFields:{},touched:h?d.current.touched:{},errors:r?d.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})},jr=(r,i={})=>{if(de){for(const s of Object.values(l.current))if(s){const{ref:h,options:b}=s,y=or(h)&&Array.isArray(b)?b[0].ref:h;if(ye(y))try{y.closest("form").reset();break}catch{}}}l.current={},F.current=Object.assign({},r||F.current),r&&Re(""),Object.values(A.current).forEach(s=>pr(s)&&s()),x.current=o?{}:Q(r||F.current),Er(i)};f.useEffect(()=>{n&&I.current.isValid&&je(),he.current=he.current||!de?he.current:Hr(l,Fe)},[Fe,F.current]),f.useEffect(()=>()=>{he.current&&he.current.disconnect(),ge.current=!0,Object.values(l.current).forEach(r=>Fe(r,!0))},[]),!n&&I.current.isValid&&(oe.isValid=se(T.current,E.current)&&k(d.current.errors));const Ze={trigger:Ve,setValue:f.useCallback(vr,[Je,Ve]),getValues:f.useCallback(ae,[]),register:f.useCallback(Ar,[F.current]),unregister:f.useCallback(xr,[]),formState:ne?new Proxy(oe,{get:(r,i)=>{if(i in r)return I.current[i]=!0,r[i]}}):oe},Sr=f.useMemo(()=>Object.assign({isFormDirty:De,updateWatchedValue:Ie,shouldUnregister:o,updateFormState:w,removeFieldEventListener:Se,watchInternal:Me,mode:N.current,reValidateMode:{isReValidateOnBlur:qe,isReValidateOnChange:ze},validateResolver:n?je:void 0,fieldsRef:l,resetFieldArrayFunctionRef:A,useWatchFieldsRef:C,useWatchRenderFunctionsRef:P,fieldArrayDefaultValuesRef:V,validFieldsRef:T,fieldsWithValidationRef:E,fieldArrayNamesRef:j,readFormStateRef:I,formStateRef:d,defaultValuesRef:F,shallowFieldsStateRef:x,fieldArrayValuesRef:L},Ze),[F.current,Ie,o,Se,Me]);return Object.assign({watch:mr,control:Sr,handleSubmit:kr,reset:f.useCallback(jr,[]),clearErrors:f.useCallback(Vr,[]),setError:f.useCallback(Rr,[]),errors:oe.errors},Ze)}/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function qr(e,t){var n={};for(var c in e)Object.prototype.hasOwnProperty.call(e,c)&&t.indexOf(c)<0&&(n[c]=e[c]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,c=Object.getOwnPropertySymbols(e);a<c.length;a++)t.indexOf(c[a])<0&&Object.prototype.propertyIsEnumerable.call(e,c[a])&&(n[c[a]]=e[c[a]]);return n}const Ge=f.createContext(null);Ge.displayName="RHFContext";const zr=()=>f.useContext(Ge),et=e=>{var{children:t}=e,n=qr(e,["children"]);return f.createElement(Ge.Provider,{value:Object.assign({},n)},t)};var Kr=()=>{const e=typeof performance===xe?Date.now():performance.now()*1e3;return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const n=(Math.random()*16+e)%16|0;return(t=="x"?n:n&3|8).toString(16)})};function rt({control:e,name:t,defaultValue:n}){const c=zr(),{useWatchFieldsRef:a,useWatchRenderFunctionsRef:u,watchInternal:o,defaultValuesRef:g}=e||c.control,l=f.useState()[1],V=f.useRef(),L=f.useRef(n);return f.useEffect(()=>{const m=V.current=Kr(),C=u.current,P=a.current;return P[m]=new Set,C[m]=()=>l({}),o(t,L.current,m),()=>{delete P[m],delete C[m]}},[t,u,a,o,L]),V.current?o(t,L.current,V.current):M(n)?z(t)?O(g.current,t):Array.isArray(t)?t.reduce((m,C)=>Object.assign(Object.assign({},m),{[C]:O(g.current,C)}),{}):g.current:n}const Ur=(e,t)=>Array.isArray(e.inner)&&e.inner.length?e.inner.reduce((n,{path:c,message:a,type:u})=>{const o=n[c]&&n[c].types||{},g=c||u;return Object.assign(Object.assign({},n),g?{[g]:Object.assign(Object.assign({},n[g]||{message:a,type:u}),t?{types:Object.assign(Object.assign({},o),{[u]:o[u]?[...[].concat(o[u]),a]:a})}:{})}:{})},{}):{[e.path]:{message:e.message,type:e.type}},Yr=(e,t={abortEarly:!1})=>async(n,c,a=!1)=>{try{return t.context,{values:await e.validate(n,Object.assign(Object.assign({},t),{context:c})),errors:{}}}catch(u){const o=Ur(u,a);return{values:{},errors:Ce(o)}}},Jr=Object.freeze(Object.defineProperty({__proto__:null,yupResolver:Yr},Symbol.toStringTag,{value:"Module"})),Qr=wr(Jr);var tt=Qr;class nt{static errorMessage(t,n,c,a,u=null){var g;if(u)return u;if(!a&&!c[t])return null;const o=n[t];return((g=o==null?void 0:o[0])==null?void 0:g.message)||(o==null?void 0:o.message)||o||null}}export{et as F,zr as a,nt as b,rt as c,Zr as u,tt as y};
